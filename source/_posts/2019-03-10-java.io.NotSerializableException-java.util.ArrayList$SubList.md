---
layout: post
title: java.io.NotSerializableException-java.util.ArrayList$SubList
date: 2019-01-04
category: [程序媛]
tags:
  - Java
---

最近通过 dubbo 调用一个接口报出了序列化错误，对方需要的入参是一个 list，我传的也是个 list，本来以为不会有问题呢，后来看了下日志发现如下报错：

> Caused by: java.io.NotSerializableException: java.util.ArrayList$SubList
> at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
> at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
> at com.esotericsoftware.kryo.serializers.JavaSerializer.write(JavaSerializer.java:30)

当然，原因也是很容易找到的。因为我要访问的接口是一个批量接口，限制每次传递 10 个 ID，但是我这边每次可能有上百个 ID，所以就用了 guava 的 partion 方法进行了切分，但是 Lists.partition 的返回值是 subList，而且 subList (RandomAccessSubList) 没有实现序列化，所以就报错啦。

Lists.partition 的定义如下：

``` Java
 /**
 * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,
 * each of the same size (the final list may be smaller). For example,
 * partitioning a list containing {@code [a, b, c, d, e]} with a partition
 * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing
 * two inner lists of three and two elements, all in the original order.
 *
 * <p>The outer list is unmodifiable, but reflects the latest state of the
 * source list. The inner lists are sublist views of the original list,
 * produced on demand using {@link List#subList(int, int)}, and are subject
 * to all the usual caveats about modification as explained in that API.
 *
 * @param list the list to return consecutive sublists of
 * @param size the desired size of each sublist (the last may be
 *     smaller)
 * @return a list of consecutive sublists
 * @throws IllegalArgumentException if {@code partitionSize} is nonpositive
 */
public static <T> List<List<T>> partition(List<T> list, int size) {
  checkNotNull(list);
  checkArgument(size > 0);
  return (list instanceof RandomAccess)
      ? new RandomAccessPartition<T>(list, size)
      : new Partition<T>(list, size);
}
```

编写测试代码如下：

<!--more-->

``` Java
public static void main(String[] args) throws IOException, InterruptedException, ExecutionException {
    ArrayList<Integer> list1 = new ArrayList<>() {{
        add(1);
        add(2);
        add(3);
    }};

    List<List<Integer>> partitionList = Lists.partition(list1, 10);
    if (partitionList.get(0) instanceof java.io.Serializable) {
        System.out.println(partitionList.get(0).getClass().getName() + " implement serializable");
    } else {
        System.out.println(partitionList.get(0).getClass().getName() + " does not implement serializable");
    }

    ArrayList<Integer> newList = new ArrayList<>(partitionList.get(0));
    if (newList instanceof java.io.Serializable) {
        System.out.println(newList.getClass().getName() + " implement serializable");
    } else {
        System.out.println(newList.getClass().getName() + " does not implement serializable");
    }
}
```

output：

> java.util.ArrayList$SubList does not implement serializable
> java.util.ArrayList implement serializable

修复的方法就是 new 一个新的 ArrayList 啦：

```
ArrayList<String> list = new ArrayList<String>(originalList.subList(0, 10));
```

参考资料：
- [java.io.NotSerializableException: java.util.ArrayList$SubList](http://www.voidcn.com/article/p-facmwcwh-bqx.html)
- [resolve a java.util.ArrayList$SubList notSerializable Exception](https://stackoverflow.com/questions/26568205/resolve-a-java-util-arraylistsublist-notserializable-exception)

