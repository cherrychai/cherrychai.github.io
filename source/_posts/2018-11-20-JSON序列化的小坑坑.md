---
layout: post
title: JSON序列化的小坑坑
date: 2018-11-20
category: [技术]
tags: 
---

最近某同学解析一段 json body，由于提供方的是非强类型的语言，所以传过来的某个字段（假设字段的名称为 uid）有时为 string，有时为 int，也就是说我们看到的 json 可能是一下两种样式：

-    {"uid":"1234"}
-    {"uid":1234}

这样会导致使用强类型语言的调用方无法使用一个确定的类型去解析这个 json body，而且有的时候可能还会对排查问题造成一些困扰。

``` java
public static void main(String[] args) {
    List<String> contentList = Arrays.asList("{\"uid\":1234}", "{\"uid\":\"5678\"}");

    for (String content : contentList) {
        try {
            Map<String, String> bodyValueMap = JSON.parseObject(content, Map.class);

            ... ... //省略代码 n 行

            String uid = Optional.ofNullable(bodyValueMap.get("uid")).map(String::valueOf).orElse("0");
            log.info("uid = {}", uid);
        } catch (Exception e) {
            log.error("exception: {}", e);
        }
    }
}
```


这个地方如愿抛出了com.alibaba.fastjson.JSONException: parseInt error, field : uid，不过是在第 8 行抛出来的，而不是在第 6 行，这个同学就觉得非常困惑，这一行不应该有什么问题啊，使用姿势很正确啊。但是后来改成用 Map<String, Object> 接收就没有问题了。后来研究了一下发现其实在做 JSON.parseObject 会将原来的类型擦除，所以这个地方并不会报错，但是在取出来的时候会转成定义的 String 类型，然后就报错了。其实是个小问题，主要是报错的地方不符合预期，然后一开始又不知道对方会传那么奇怪的 json，会导致排查错了方向。后来又深入了解了下 fastjson，发现正确的代码姿势应该如下所示。
<!--more-->

``` java
public static void main(String[] args) {
    List<String> contentList = Arrays.asList("{\"uid\":1234}", "{\"uid\":\"5678\"}");

    for (String content : contentList) {
        try {
            Map<String, Object> bodyValueMap = JSON.parseObject(content, Map.class);
            String uid = Optional.ofNullable(bodyValueMap.get("uid")).map(String::valueOf).orElse("0");
            log.info("uid = {}", uid);
        } catch (Exception e) {
            log.error("exception: {}", e);
        }

        try {
            Map<String, String> bodyValueMap = JSON.parseObject(content, new TypeReference<Map<String, String>>() {});
            String uid = Optional.ofNullable(bodyValueMap.get("uid")).map(String::valueOf).orElse("0");
            log.info("uid = {}", uid);
        } catch (Exception e) {
            log.error("exception: {}", e.getMessage());
        }

        try {
            Map<String, Integer> bodyValueMap = JSON.parseObject(content, new TypeReference<Map<String, Integer>>() {});
            String uid = Optional.ofNullable(bodyValueMap.get("uid")).map(String::valueOf).orElse("0");
            log.info("uid = {}", uid);
        } catch (Exception e) {
            log.error("exception: {}", e);
        }
    }
}
```

搞完这个又想到之前解析某部门的 json，有些类型可能是 string，也可能是 list，最后也没有想到很好的方法来解析，只能用 string 接收之后判断开头是什么字符（23333，感觉也是很机智的方法），真的是非常头痛啊。

